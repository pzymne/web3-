一、学习内容
1、数据库标准库开发：
  1）驱动安装和导入，例如 import _ "github.com/go-sql-driver/mysql"
  2），例如 sql.Open("mysql",
  "wayne:wayne@tcp(localhost:3306)/test")
  3）使用db提供的接口函数
  4）db.Prepare预编译并使用参数化查询
  对预编译的SQL语句进行缓存，省去了每次解析优化该SQL语句的过程
  防止注入攻击
  使用返回的sql.Stmt操作数据库
2、ORM 
对象关系映射（Object Relational Mapping，ORM）。指的是对象和关系之间的映射，使用面向对象的
方式操作数据库。
举例，有表student，字段为id int，name varchar，age int
可以认为ORM是一种高级抽象，对象的操作最终还是会转换成对应关系数据库操作的SQL语句，数据库
操作的结构会被封装成对象。
GORM 
GORM是一个友好的、功能全面的、性能不错的基于Go语言实现的ORM库
模型定义 
 GORM 倾向于约定优于配置
约定使用名为ID的属性会作为主键
约定使用snake_cases作为表名，结构体名使用驼峰命名
结构体命名为employee，那么数据库表名就是employees
约定使用snake_case作为字段名，字段采用首字母大写的大驼峰命名
属性名为FirstName，默认对应数据库表的字段名为first_name
如果不遵从以上约定就要自定义配置
新增 
 type Student struct {
 ID       
int        
Name     
string     
// 缺省主键bigint AUTO_INCREMENT
 `gorm:"size:48"` //`gorm:"not 
null;type:varchar(48);comment:姓名"`
 Age      
byte       
// byte=>tinyint unsigned
 Birthday *time.Time // datetime，也可以用时间戳int64
 Gender   
byte       
}
 //`gorm:"type:tinyint"`
 func (s *Student) String() string {
 return fmt.Sprintf("%d: %s %d", s.ID, s.Name, s.Age)
 }

 // 新增一条
n := time.Now()
 s := Student{Name: "Tom", Age: 20, Birthday: &n} // 构建实例
fmt.Println(s)
 result := db.Create(&s) // 新增，传入指针
fmt.Println(s) // 注意前后ID的变化
fmt.Println(result.Error)
 fmt.Println(result.RowsAffected)

 // 新增多条
n := time.Now()
 s := Student{Name: "Tom", Age: 20, Birthday: &n}
 fmt.Println(s)
 result := db.Create([]*Student{&s, &s, &s}) // 传入指针的切片
fmt.Println(s)
 fmt.Println(result.Error)
 fmt.Println(result.RowsAffected)
查询一条 
Take被转换为Limit 1。

 var s Student
 fmt.Println(s) // 零值
r := db.Take(&s) // LIMIT 1
 fmt.Println(s) // 被填充
fmt.Println(r)
 fmt.Println(r.Error)
 
 r := db.First(&s) // ORDER BY `students`.`id` LIMIT 1
 
 r := db.Last(&s) // ORDER BY `students`.`id` DESC LIMIT 1
根据id查，可以使用下面的方式

 r := db.First(&s, 15)

 var s = Student{ID: 16}
 r := db.First(&s)
时间相关错误 
1、时间类型字段
上例错误如下，主要是使用了*time.Time，而不是string。

 sql: Scan error on column index 3, name "birthday": unsupported Scan, storing 
driver.Value type []uint8 into type *time.Time
 []byte 转 *time.Time失败了
解决方案
在连接字符串中增加parseTime=true，这样时间类型就会自动转化为time.Time类型

 dsn := "wayne:wayne@tcp(localhost:3306)/test?
 charset=utf8mb4&parseTime=true"
也可以
Birthday string ，拿到Birthday字符串后，必要时，自行转换成时间类型
2、UTC时间
Create写入的时间，也就是说time.Now()取当前时区时间，但是存入数据库的时间是UTC时间。
Take拿回的时间也是UTC时间，可以通过s.Birthday.Local()转成当前时区时间。
如果想存入的时间或读取的时间直接是当前时区时间，可以使用loc参数loc=Local。
如果loc=Local
存入时，数据库字段中的时间就是当前时区的时间值
读取时，数据库字段中的时间就被解读为当前时区
千万不要存入和读取的时区不一致，例如数据库时采用Local存入，却使用UTC解读时间，会造成时间时
区的混乱。应该保证时间存入、读取时区一致。
一定要统一项目中数据库中时间类型字段的时区
可以统一采用UTC，本地化显示时转换为当前时区即可
可以统一采用时间戳
 
查询所有 
distinct 
投影 
投影是关系模型的操作，就是选择哪些字段。
Limit和Offset 
dsn := "wayne:wayne@tcp(localhost:3306)/test?
 charset=utf8mb4&parseTime=true&loc=Local"
 // time/zoneinfo.go
 func LoadLocation(name string) (*Location, error) {
    if name == "" || name == "UTC" {
        return UTC, nil
    }
    if name == "Local" {
        return Local, nil
    }
    ...省略
}

 var students []*Student
 r := db.Find(&students)
 fmt.Println(r)
 fmt.Println(r.Error)
 fmt.Println(students)

 var students []*Student
 r := db.Distinct("name").Find(&students) // 投影的字段是什么？
fmt.Println(students) // 容器里每个实例是什么样子？

 var students []*Student
 r := db.Select("id", "name", "age").Find(&students)
 r := db.Select([]string{"id", "name", "age"}).Find(&students)
 fmt.Println(students)

 var students []*Student
 r := db.Limit(2).Offset(2).Find(&students)
 fmt.Println(students) // 容器里每个实例是什么样子？

条件查询 
1、字符串条件
 var students []*Student
 r := db.Where("name = ?", "Tom").Find(&students)
 r := db.Where("name <> ?", "Tom").Find(&students)
 r := db.Where("name in ?", []string{"jerry", "tom"}).Find(&students)
 r := db.Where("name like ?", "t%").Find(&students)
 r := db.Where("name like binary ?", "T%").Find(&students)
 r := db.Where("name like ? and age > ?", "t%", 20).Find(&students)
 r := db.Where("id between ? and ?", 15, 17).Find(&students) // id范围[15, 17]
 r := db.Where("id = ? or id = ?", 15, 17).Find(&students) // or
 2、struct或map条件
 r := db.Where(14, 16, 17).Find(&students)
 r := db.Where([]int{14, 16, 17}).Find(&students) // WHERE `students`.`id` IN 
(14,16,17)
 r := db.Where(&Student{}).Find(&students) // find all
 r := db.Find(&students) // find all 更简洁
r := db.Where(&Student{ID: 15}).Find(&students)
 r := db.Where(15).Find(&students) // 更简洁
r := db.Where(&Student{ID: 15, Name: "Tom"}).Find(&students) // and
 r := db.Where(map[string]interface{}{"name": "Tom", "id": 
16}).Find(&students) // and
 struct条件中出现了零值，例如
db.Where(&Student{Name: "Tom", Age: 0}) ，Age是零值，就不会
出现在条件中。

 r := db.Where(&Student{Name: "Tom", Age: 20}, "name", "age").Find(&students) 
// 指定使用结构体里面的name和age字段作为条件，and
 3、Not
将Where换成Not即可，表示条件取反。

 r := db.Not("id = ? or id = ?", 15, 17).Find(&students)
 r := db.Not("name = ?", "Tom").Find(&students)
 4、Or
 Or的用法和Where一样。
Where().Where()是And关系，Where().Or()是Or关系。

 r := db.Where("name = ?", "Tom").Or("name=?", "Jerry").Find(&students)
 r := db.Where("name = ?", "Tom").Or(&Student{Name: "Jerry"}).Find(&students)
排序 
 
分组 
r := db.Order("id desc").Find(&students) // ORDER BY id desc
 r := db.Order("name, id desc").Find(&students)         // ORDER BY name,id 
desc
 r := db.Order("name").Order("id desc").Find(&students) // ORDER BY name,id 
desc

 r := db.Group("id").Find(&students) // GROUP BY `id`
 r := db.Group("name").Find(&students) // GROUP BY `name`
 r := db.Group("id").Group("name").Find(&students) // GROUP BY `id`,`name`

 // SELECT name, count(id) as c FROM `students` GROUP BY `name`
 r := db.Select("name, count(id) as c").Group("name").Find(&students)
 // 但是students中没有属性来保存count的值

 // 使用Rows()返回所有行，自行获取字段值，但是要用Table指定表名
type Result struct {
    name  string
    count int
 }
 var r = Result{}
 rows, err := db.Table("students").Select("name, count(id) as 
c").Group("name").Rows()
 fmt.Println(err)
 // 遍历每一行，填充2个属性的结构体实例
for rows.Next() {
    rows.Scan(&r.name, &r.count)
    fmt.Println(r, "@@@")
 }

 type Result struct { // 和Select的投影字段对应
    Name  string
    Count int
 }
 var r = Result{}
 rows, err := db.Table("students").Select("name, count(id) as 
c").Group("name").Having("c > 3").Rows()
 fmt.Println(err)
 // 遍历每一行，填充2个属性的结构体实例
for rows.Next() {
    rows.Scan(&r.Name, &r.Count)
    fmt.Println(r, "@@@")
 }
 // 使用Scan填充容器，注意字段名要大写开头
type Result struct {
    Name string

 
Join 
 
 
    C    int // 或Count int `gorm:"column:c"`
 }
 var rows = []*Result{}
 db.Table("students").Select("name, count(id) as c").Group("name").Having("c 
> 3").Scan(&rows) // Find(&rows)
 for i, r := range rows {
    fmt.Printf("%d, %T %#[2]v\n", i, r)
 }

 SELECT
    employees.emp_no, 
    employees.first_name, 
    employees.last_name, 
    salaries.salary
 FROM
    employees
    INNER JOIN
    salaries
    ON 
        employees.emp_no = salaries.emp_no

 type Result struct {
    EmpNo     int
    FirstName string
    LastName  string
    Salary    int
 }
 rows, err := db.Table("employees as e").Select("e.emp_no, first_name, 
last_name, salary").
 Joins("join salaries as s on e.emp_no = s.emp_no").Rows() // 比较麻烦，还是建议
使用Find或Scan
 fmt.Println(err)
 var r Result
 for rows.Next() {
    rows.Scan(&r.EmpNo, &r.FirstName, &r.LastName, &r.Salary)
    fmt.Println(r, "###")
 }

 type Result struct {
    EmpNo     int
    FirstName string
    LastName  string
    Salary    int
 }
 var results = []*Result{}

Left Join 
r := db.Table("employees as e").Select("e.emp_no, first_name, last_name, 
salary").
    Joins("join salaries on e.emp_no = salaries.emp_no").Find(&results) // 
Scan(&results)
 fmt.Println(r)
 fmt.Println(r.Error)
 fmt.Println(r.RowsAffected)
 fmt.Println("~~~~~~~~~~~~~~~~~~~~~~~~~~~")
 for i, row := range results {
    fmt.Println(i, row)
 }

 db.Select("e.emp_no, first_name, last_name, salary").Table("employees as e").
    Joins("left join salaries on e.emp_no = salaries.emp_no").Find(&results)
 1
 2
 package main
 import (
    "fmt"
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
 )
 func main() {
    db, err := gorm.Open(mysql.Open("wayne:wayne@/test"), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    if err != nil {
        panic(err)
    }
    type Employee struct {
        EmpNo     int
        BirthDate string
        FirstName string
        LastName  string
        Gender    byte
        HireDate  string
    }
    type Result struct {
        Employee // 嵌套
        Salary int
    }
    var results []*Result
    r := db.Select("e.*, s.salary").Table("employees as e").Joins("left join 
salaries as s on e.emp_no=s.emp_no").Find(&results)
    fmt.Println(r.Error)
    fmt.Println("~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    for i, v := range results {
        fmt.Println(i+1, v)
 
更新 
}
 }
 https://gorm.io/zh_CN/docs/update.html
先查后改：先查到一个实例，对这个实例属性进行修改，然后调用db.Save()方法保存。
db.Save()方法会保存所有字段，对于没有主键的实例相当于Insert into，有主键的实例相当于Update。

 // 先查
var student Student
 db.First(&student)
 fmt.Println(student)
 student.Age += 10
 student.Name = "Sam"
 // 后修改
db.Save(&student)
 fmt.Println(student)
 Update单个字段

 r := db.Model(&Student{ID: 13}).Update("age", 11) // 更新符合条件的所有记录的一个
字段
// UPDATE `students` SET `age`=11 WHERE `id` = 13
 r := db.Model(&Student{}).Update("age", 11) // 没有指定ID或Where条件，是全表更新
age字段，这是非常危险的
fmt.Println(r.Error) // 会报WHERE conditions required错误，更新失败，这是一种保护
Updates更新多列
多个键值对，使用map或结构体实例传参。
同样，没有指定ID或Where条件，是全表更新age字段，这是非常危险的，报WHERE conditions
 required错误1 2
 r := db.Model(&Student{}).Where("age < ?", 20).Updates(map[string]interface{}
 {"name": "John", "age": 23})
 fmt.Println(r.Error)

 r := db.Model(&Student{}).Where("age < ?", 24).Updates(Student{Name: "John", 
Age:18})
 fmt.Println(r.Error)
删除 
https://gorm.io/zh_CN/docs/delete.html
删除操作是危险的，慎重操作！1
 
 result := db.Delete(&Student{})
 fmt.Println(result.Error)
 // 报WHERE conditions required错误，这是全表删除，危险

 result := db.Delete(&Student{}, 15) // 指定主键
fmt.Println(result.Error)
 db.Delete(&Student{}, []int{15, 16, 18}) // DELETE FROM `students` WHERE 
`students`.`id` IN (15,16,18)

 result := db.Where("id > ?", 15).Delete(&Student{}) // 删除符合条件的一批
fmt.Println(result.Error
二、对当前学习内容的思考

三、遇到的问题
1、之前本人工作中用到的代码管理工具主要是SVN，那么对于web2或web3一般是用git吗？git如何使用的？经常看面试要求里面有这一项
2、go语言中sql语句数据库参数化查询怎么防止注入攻击的？
3、gin中间件的作用是啥？没太看明白啥用处

四、任务（4个）
1、任务一：
1）题目：只出现一次的数字：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。可以使用 for 循环遍历数组，结合 if 条件判断和 map 数据结构来解决，例如通过 map 记录每个元素出现的次数，然后再遍历 map 找到出现次数为1的元素。
代码如下：
package main

import "fmt"

func main() {
	//var arr [15]int = [15]int{1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8}
	var m_story = map[string]int{"1": 2, "2": 2, "3": 2, "4": 2, "5": 1, "6": 2, "7": 2, "8": 2}

	for i, v := range m_story {
		if v == 1 {
			fmt.Printf("%v", i)
		}

	}

}

2）题目：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效
代码如下：
package main

import "fmt"

func isValid(s string) bool {
	// 使用栈来存储左括号
	stack := []rune{}

	// 使用哈希表建立括号映射关系
	bracketMap := map[rune]rune{
		')': '(',
		'}': '{',
		']': '[',
	}

	// 遍历字符串中的每个字符
	for _, ch := range s {
		// 如果是左括号，压入栈中
		if ch == '(' || ch == '{' || ch == '[' {
			stack = append(stack, ch)
		} else {
			// 如果是右括号，检查栈是否为空
			if len(stack) == 0 {
				return false
			}

			// 获取栈顶元素
			top := stack[len(stack)-1]

			// 检查括号是否匹配
			if top != bracketMap[ch] {
				return false
			}

			// 弹出栈顶元素
			stack = stack[:len(stack)-1]
		}
	}

	// 最后检查栈是否为空
	return len(stack) == 0
}

func main() {
	fmt.Println(isValid("()"))     // true
	fmt.Println(isValid("()[]{}")) // true
	fmt.Println(isValid("(]"))     // false
	fmt.Println(isValid("([)]"))   // false
	fmt.Println(isValid("{[]}"))   // true
	fmt.Println(isValid(""))       // true（空字符串有效）
}

3）、题目：查找字符串数组中的最长公共前缀
代码如下：
package main

import "fmt"

func longestCommonPrefix(strs []string) string {
	if len(strs) == 0 {
		return ""
	}

	// 以第一个字符串为基准
	prefix := strs[0]

	for i := 1; i < len(strs); i++ {
		// 比较当前字符串和前缀的公共部分
		j := 0
		for j < len(prefix) && j < len(strs[i]) && prefix[j] == strs[i][j] {
			j++
		}

		// 更新前缀为更短的部分
		prefix = prefix[:j]

		// 如果前缀为空，直接返回
		if prefix == "" {
			return ""
		}
	}

	return prefix
}

func main() {
	testCases := [][]string{
		{"flower", "flow", "flight"},
		{"dog", "racecar", "car"},
		{"", "abc", "def"},
		{"same", "same", "same"},
		{"a"},
		{},
	}

	for _, strs := range testCases {
		result := longestCommonPrefix(strs)
		fmt.Printf("strs = %v, LCP = \"%s\"\n", strs, result)
	}
}

/*
输出：
strs = [flower flow flight], LCP = "fl"
strs = [dog racecar car], LCP = ""
strs = [ abc def], LCP = ""
strs = [same same same], LCP = "same"
strs = [a], LCP = "a"
strs = [], LCP = ""
*/

4）题目：给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一
代码如下：
package main

import "fmt"

func plusOne(digits []int) []int {
	n := len(digits)

	// 从最后一位开始加1
	for i := n - 1; i >= 0; i-- {
		if digits[i] < 9 {
			digits[i]++
			return digits
		}
		// 当前位是9，加1后变为0，进位
		digits[i] = 0
	}

	// 如果所有位都是9，例如[9,9,9] -> [1,0,0,0]
	// 需要在前方添加一个1
	return append([]int{1}, digits...)
}

func main() {
	testCases := [][]int{
		{1, 2, 3},    // 123 + 1 = 124
		{4, 3, 2, 1}, // 4321 + 1 = 4322
		{9},          // 9 + 1 = 10
		{9, 9},       // 99 + 1 = 100
		{8, 9, 9},    // 899 + 1 = 900
		{1, 9, 9, 9}, // 1999 + 1 = 2000
	}

	for _, digits := range testCases {
		fmt.Printf("%v -> ", digits)

		result := plusOne(digits)
		fmt.Printf("%v\n", result)
	}
}

/*
输出：
[1 2 3] -> [1 2 4]
[4 3 2 1] -> [4 3 2 2]
[9] -> [1 0]
[9 9] -> [1 0 0]
[8 9 9] -> [9 0 0]
[1 9 9 9] -> [2 0 0 0]
*/

5）题目：删除有序数组中的重复项：给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。可以使用双指针法，一个慢指针 i 用于记录不重复元素的位置，一个快指针 j 用于遍历数组，当 nums[i] 与 nums[j] 不相等时，将 nums[j] 赋值给 nums[i + 1]，并将 i 后移一位。
代码如下：
package main

import "fmt"

func removeDuplicates(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	// 慢指针，指向下一个不重复元素应该放置的位置
	slow := 0

	// 快指针，遍历整个数组
	for fast := 1; fast < len(nums); fast++ {
		// 如果当前元素与慢指针指向的元素不同
		if nums[fast] != nums[slow] {
			// 慢指针向前移动一位
			slow++
			// 将不重复的元素放到慢指针位置
			nums[slow] = nums[fast]
		}
	}

	// 返回唯一元素的个数（慢指针索引+1）
	return slow + 1
}

func main() {
	testCases := [][]int{
		{1, 1, 2},
		{0, 0, 1, 1, 1, 2, 2, 3, 3, 4},
		{1, 2, 3},
		{1, 1, 1, 1},
		{},
		{1},
	}

	for _, nums := range testCases {
		fmt.Printf("原数组: %v\n", nums)
		k := removeDuplicates(nums)
		fmt.Printf("去重后前 %d 个元素: %v\n", k, nums[:k])
		fmt.Println()
	}
}

/*
输出：
原数组: [1 1 2]
去重后前 2 个元素: [1 2]

原数组: [0 0 1 1 1 2 2 3 3 4]
去重后前 5 个元素: [0 1 2 3 4]

原数组: [1 2 3]
去重后前 3 个元素: [1 2 3]

原数组: [1 1 1 1]
去重后前 1 个元素: [1]

原数组: []
去重后前 0 个元素: []

原数组: [1]
去重后前 1 个元素: [1]
*/

6）题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数
代码如下：
package main

import "fmt"

func twoSum(nums []int, target int) []int {
	// 创建一个map，key是数字，value是该数字的索引
	numMap := make(map[int]int)

	for i, num := range nums {
		complement := target - num
		// 检查补数是否已经在map中
		if idx, exists := numMap[complement]; exists {
			// 找到了，返回两个索引
			return []int{idx, i}
		}
		// 没找到，将当前数字和索引存入map
		numMap[num] = i
	}

	// 题目保证有解，这里返回空切片只是为了完整性
	return []int{}
}

func main() {
	// 测试用例
	testCases := []struct {
		nums   []int
		target int
	}{
		{[]int{2, 7, 11, 15}, 9},
		{[]int{3, 2, 4}, 6},
		{[]int{3, 3}, 6},
	}

	for _, tc := range testCases {
		result := twoSum(tc.nums, tc.target)
		fmt.Printf("nums=%v, target=%d, result=%v\n", tc.nums, tc.target, result)
	}
}

2、任务二
1）题目 ：编写一个Go程序，定义一个函数，该函数接收一个整数指针作为参数，在函数内部将该指针指向的值增加10，然后在主函数中调用该函数并输出修改后的值。
package main

import "fmt"

// 函数接收一个整数指针作为参数
func addTen(ptr *int) {
    // 通过指针修改原始值
    *ptr = *ptr + 10
}

func main() {
    // 定义一个整数变量
    value := 5
    fmt.Printf("修改前的值: %d\n", value)
    
    // 将变量的地址传递给函数
    addTen(&value)
    
    fmt.Printf("修改后的值: %d\n", value)
    
    // 更复杂的示例
    fmt.Println("\n--- 更多示例 ---")
    
    // 示例1: 使用new创建指针
    ptr := new(int)
    *ptr = 20
    fmt.Printf("初始值: %d\n", *ptr)
    addTen(ptr)
    fmt.Printf("增加10后: %d\n", *ptr)
    
    // 示例2: 直接传递变量的地址
    num := 100
    fmt.Printf("\nnum的初始值: %d\n", num)
    addTen(&num)
    fmt.Printf("num增加10后: %d\n", num)
    
    // 示例3: 演示指针传递的本质
    fmt.Println("\n--- 指针传递演示 ---")
    a := 50
    fmt.Printf("调用函数前 a = %d, 地址 = %p\n", a, &a)
    addTen(&a)
    fmt.Printf("调用函数后 a = %d, 地址 = %p\n", a, &a)
    
    // 示例4: 不使用指针的情况（对比）
    fmt.Println("\n--- 不使用指针的对比 ---")
    b := 30
    fmt.Printf("不使用指针的函数调用前: b = %d\n", b)
    // 值传递不会修改原始值
    noPointerFunc(b)
    fmt.Printf("不使用指针的函数调用后: b = %d (未改变)\n", b)
    
    // 使用指针
    withPointerFunc(&b)
    fmt.Printf("使用指针的函数调用后: b = %d (已改变)\n", b)
}

// 不使用指针的函数（值传递）
func noPointerFunc(x int) {
    x = x + 10
}

// 使用指针的函数
func withPointerFunc(ptr *int) {
    *ptr = *ptr + 10
}

2）实现一个函数，接收一个整数切片的指针，将切片中的每个元素乘以2。
考察点 ：指针运算、切片操作。
代码如下：
package main

import "fmt"

// 接收整数切片的指针，将每个元素乘以2
func multiplyByTwo(slicePtr *[]int) {
    // 解引用获取切片
    slice := *slicePtr
    for i := range slice {
        slice[i] *= 2
    }
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    fmt.Println("原始切片:", nums)
    
    // 传递切片的指针
    multiplyByTwo(&nums)
    
    fmt.Println("修改后切片:", nums)
}
3）编写一个程序，使用 go 关键字启动两个协程，一个协程打印从1到10的奇数，另一个协程打印从2到10的偶数。
代码如下：
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		defer wg.Done()
		for i := 1; i <= 10; i += 2 {
			fmt.Printf("奇数：%d\n", i)
		}
	}()

	go func() {
		defer wg.Done()
		for i := 2; i <= 10; i += 2 {
			fmt.Printf("偶数:%d\n", i)
		}
	}()

	wg.Wait()
}

4）题目：设计一个任务调度器，接收一组任务（可以用函数表示），并使用协程并发执行这些任务，同时统计每个任务的执行时间。
代码如下：
package main

import (
	"fmt"
	"sync"
	"time"
)

type Task func()

type TaskScheduler struct {
	maxConcurrency int
	wg             sync.WaitGroup
	semaphore      chan struct{}
}

func NewTaskScheduler(maxConcurrency int) *TaskScheduler {
	if maxConcurrency <= 0 {
		maxConcurrency = 5
	}
	return &TaskScheduler{
		maxConcurrency: maxConcurrency,
		semaphore:      make(chan struct{}, maxConcurrency),
	}
}

func (ts *TaskScheduler) Run(tasks []Task) []time.Duration {
	durations := make([]time.Duration, len(tasks))
	var mu sync.Mutex

	for i, task := range tasks {
		ts.wg.Add(1)

		go func(idx int, t Task) {
			defer ts.wg.Done()

			// 控制并发数
			ts.semaphore <- struct{}{}
			defer func() { <-ts.semaphore }()

			// 记录执行时间
			start := time.Now()
			t()
			duration := time.Since(start)

			mu.Lock()
			durations[idx] = duration
			mu.Unlock()

			fmt.Printf("任务 %d 执行完成，耗时: %v\n", idx+1, duration)
		}(i, task)
	}

	ts.wg.Wait()
	return durations
}

func main() {
	// 创建任务列表
	tasks := []Task{
		func() { time.Sleep(500 * time.Millisecond) },
		func() { time.Sleep(300 * time.Millisecond) },
		func() { time.Sleep(700 * time.Millisecond) },
		func() { time.Sleep(200 * time.Millisecond) },
		func() { time.Sleep(400 * time.Millisecond) },
	}

	// 创建调度器并执行任务
	scheduler := NewTaskScheduler(2) // 最大并发数2
	fmt.Println("开始执行任务...")

	durations := scheduler.Run(tasks)

	// 统计信息
	var total time.Duration
	for i, d := range durations {
		total += d
		fmt.Printf("任务%d: %v\n", i+1, d)
	}
	fmt.Printf("平均执行时间: %v\n", total/time.Duration(len(tasks)))
}

5）题目：定义一个 Shape 接口，包含 Area() 和 Perimeter() 两个方法。然后创建 Rectangle 和 Circle 结构体，实现 Shape 接口。在主函数中，创建这两个结构体的实例，并调用它们的 Area() 和 Perimeter() 方法。
代码如下：
package main

import (
	"fmt"
	"math"
)

// Shape 接口
type Shape interface {
	Area() float64
	Perimeter() float64
}

// Rectangle 矩形
type Rectangle struct {
	Width, Height float64
}

func (r Rectangle) Area() float64 {
	return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
	return 2 * (r.Width + r.Height)
}

// Circle 圆形
type Circle struct {
	Radius float64
}

func (c Circle) Area() float64 {
	return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
	return 2 * math.Pi * c.Radius
}

func main() {
	// 创建矩形
	rect := Rectangle{Width: 5, Height: 3}
	fmt.Printf("矩形 - 宽: %.1f, 高: %.1f\n", rect.Width, rect.Height)
	fmt.Printf("面积: %.2f\n", rect.Area())
	fmt.Printf("周长: %.2f\n\n", rect.Perimeter())
	
	// 创建圆形
	circle := Circle{Radius: 4}
	fmt.Printf("圆形 - 半径: %.1f\n", circle.Radius)
	fmt.Printf("面积: %.2f\n", circle.Area())
	fmt.Printf("周长: %.2f\n", circle.Perimeter())
	
	// 使用接口类型
	var shape Shape
	shape = rect
	fmt.Printf("\n通过接口调用矩形面积: %.2f\n", shape.Area())
	
	shape = circle
	fmt.Printf("通过接口调用圆形周长: %.2f\n", shape.Perimeter())
}

6）题目：使用组合的方式创建一个 Person 结构体，包含 Name 和 Age 字段，再创建一个 Employee 结构体，组合 Person 结构体并添加 EmployeeID 字段。为 Employee 结构体实现一个 PrintInfo() 方法，输出员工的信息。
代码如下：
func simpleVersion() {
	// Person 结构体
	type Person struct {
		Name string
		Age  int
	}
	
	// Employee 结构体（组合Person）
	type Employee struct {
		Person     // 组合Person
		EmployeeID string
	}
	
	// PrintInfo 方法
	func (e Employee) PrintInfo() {
		fmt.Println("员工信息:")
		fmt.Printf("姓名: %s\n", e.Name)        // 可以直接访问
		fmt.Printf("年龄: %d\n", e.Age)         // 可以直接访问
		fmt.Printf("员工编号: %s\n", e.EmployeeID)
	}
	
	// 使用
	emp := Employee{
		Person: Person{
			Name: "张三",
			Age:  30,
		},
		EmployeeID: "E1001",
	}
	
	emp.PrintInfo()
}

7）题目:编写一个程序，使用通道实现两个协程之间的通信。一个协程生成从1到10的整数，并将这些整数发送到通道中，另一个协程从通道中接收这些整数并打印出来
方法一：代码如下
package main

import (
    "fmt"
    "time"
)

func main() {
    // 创建一个无缓冲通道
    ch := make(chan int)
    
    // 启动生产者协程
    go producer(ch)
    
    // 启动消费者协程
    go consumer(ch)
    
    // 主协程等待一段时间，让子协程完成工作
    time.Sleep(2 * time.Second)
    
    fmt.Println("程序结束")
}

// 生产者函数：生成1到10的整数并发送到通道
func producer(ch chan<- int) {
    fmt.Println("生产者开始工作...")
    
    for i := 1; i <= 10; i++ {
        fmt.Printf("生产者发送: %d\n", i)
        ch <- i  // 发送数据到通道
        
        // 添加短暂延迟，使执行过程更清晰可见
        time.Sleep(100 * time.Millisecond)
    }
    
    // 发送完成后关闭通道
    close(ch)
    fmt.Println("生产者工作完成，通道已关闭")
}

// 消费者函数：从通道接收整数并打印
func consumer(ch <-chan int) {
    fmt.Println("消费者开始工作...")
    
    // 使用range循环接收数据，通道关闭后自动退出循环
    for value := range ch {
        fmt.Printf("消费者接收: %d\n", value)
        time.Sleep(150 * time.Millisecond) // 消费者处理稍慢
    }
    
    fmt.Println("消费者工作完成")
}
方法二：
package main

import (
    "fmt"
    "time"
)

func main() {
    // 创建带缓冲的通道（容量为3）
    ch := make(chan int, 3)
    
    // 启动生产者协程
    go producerWithBuffer(ch)
    
    // 启动消费者协程
    go consumerWithBuffer(ch)
    
    // 等待足够时间让协程完成
    time.Sleep(3 * time.Second)
    
    fmt.Println("程序结束")
}

func producerWithBuffer(ch chan<- int) {
    fmt.Println("生产者开始工作（使用带缓冲通道）...")
    
    for i := 1; i <= 10; i++ {
        fmt.Printf("生产者发送: %d (通道长度: %d/%d)\n", 
            i, len(ch), cap(ch))
        ch <- i
        time.Sleep(50 * time.Millisecond) // 生产者较快
    }
    
    close(ch)
    fmt.Println("生产者工作完成")
}

func consumerWithBuffer(ch <-chan int) {
    fmt.Println("消费者开始工作（使用带缓冲通道）...")
    
    for value := range ch {
        fmt.Printf("消费者接收: %d (通道长度: %d/%d)\n", 
            value, len(ch), cap(ch))
        time.Sleep(200 * time.Millisecond) // 消费者较慢
    }
    
    fmt.Println("消费者工作完成")
}

8)题目：编写一个程序，使用 sync.Mutex 来保护一个共享的计数器。启动10个协程，每个协程对计数器进行1000次递增操作，最后输出计数器的值
代码如下：
package main

import (
	"fmt"
	"sync"
)

func main() {
	fmt.Println("\n=== 简洁版本（直接回答问题） ===")

	var (
		counter int
		mu      sync.Mutex
		wg      sync.WaitGroup
	)

	// 启动10个协程
	wg.Add(10)
	for i := 0; i < 10; i++ {
		go func(id int) {
			defer wg.Done()

			// 每个协程对计数器进行1000次递增
			for j := 0; j < 1000; j++ {
				mu.Lock()   // 加锁保护临界区
				counter++   // 递增操作
				mu.Unlock() // 解锁
			}
		}(i)
	}

	wg.Wait()

	fmt.Printf("最终计数器值: %d\n", counter)
	fmt.Printf("期望值: %d\n", 10*1000)
	fmt.Printf("是否一致: %v\n", counter == 10*1000)
}

9）题目 ：使用原子操作（ sync/atomic 包）实现一个无锁的计数器。启动10个协程，每个协程对计数器进行1000次递增操作，最后输出计数器的值。
代码如下：
func simpleAtomicExample() {
	fmt.Println("\n=== 简洁版本（直接回答问题） ===")
	
	var counter int64 // 必须使用 int64
	var wg sync.WaitGroup
	
	// 启动10个协程
	wg.Add(10)
	for i := 0; i < 10; i++ {
		go func(workerID int) {
			defer wg.Done()
			
			// 每个协程对计数器进行1000次递增
			for j := 0; j < 1000; j++ {
				atomic.AddInt64(&counter, 1) // 原子递增
			}
			
			fmt.Printf("Worker %d completed\n", workerID)
		}(i)
	}
	
	// 等待所有协程完成
	wg.Wait()
	
	// 输出最终结果
	fmt.Printf("\nFinal counter value: %d\n", counter)
	fmt.Printf("Expected value: %d\n", 10*1000)
	
	if counter == int64(10*1000) {
		fmt.Println("✓ Counter is correct!")
	} else {
		fmt.Println("✗ Error in counter!")
	}
}

3、任务三
1）题目1：基本CRUD操作,
假设有一个名为 students 的表，包含字段 id （主键，自增）、 name （学生姓名，字符串类型）、 age （学生年龄，整数类型）、 grade （学生年级，字符串类型）。
要求 ：
编写SQL语句向 students 表中插入一条新记录，学生姓名为 "张三"，年龄为 20，年级为 "三年级"。,
编写SQL语句查询 students 表中所有年龄大于 18 岁的学生信息。,
编写SQL语句将 students 表中姓名为 "张三" 的学生年级更新为 "四年级"。,
编写SQL语句删除 students 表中年龄小于 15 岁的学生记录。
代码如下：
- ========== 1. 创建表 ==========
CREATE TABLE IF NOT EXISTS students (
    id INT PRIMARY KEY AUTO_INCREMENT,  -- 主键，自增
    name VARCHAR(50) NOT NULL,          -- 学生姓名，非空
    age INT NOT NULL,                   -- 学生年龄，非空
    grade VARCHAR(20),                  -- 学生年级
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- 创建时间
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  -- 更新时间
);
-- 1. 插入数据
INSERT INTO students (name, age, grade) 
VALUES ('张三', 20, '三年级');

-- 2. 查询数据
SELECT * FROM students 
WHERE age > 18;

-- 3. 更新数据
UPDATE students 
SET grade = '四年级' 
WHERE name = '张三';

-- 4. 删除数据
DELETE FROM students 
WHERE age < 15;
2)题目2：事务语句,
假设有两个表： accounts 表（包含字段 id 主键， balance 账户余额）和 transactions 表（包含字段 id 主键， from_account_id 转出账户ID， to_account_id 转入账户ID， amount 转账金额）。
要求 ：
编写一个事务，实现从账户 A 向账户 B 转账 100 元的操作。在事务中，需要先检查账户 A 的余额是否足够，如果足够则从账户 A 扣除 100 元，向账户 B 增加 100 元，并在 transactions 表中记录该笔转账信息。如果余额不足，则回滚事务。
-- 简单转账事务
START TRANSACTION;

-- 1. 检查账户A余额（加锁防止并发修改）
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;

-- 2. 如果余额足够，执行转账
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- 3. 记录交易
INSERT INTO transactions (from_account_id, to_account_id, amount) 
VALUES (1, 2, 100);

-- 提交事务
COMMIT;

-- 如果余额不足，需要回滚
-- ROLLBACK;
